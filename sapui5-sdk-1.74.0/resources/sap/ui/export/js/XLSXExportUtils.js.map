{"version":3,"sources":["webpack:///XLSXExportUtils.js","webpack:///webpack/bootstrap 56e3809069578475695c","webpack:///./client/src/export-utils.js","webpack:///./client/src/provider/ODataDataProvider.js","webpack:///./client/src/provider/RequestHandler.js","webpack:///./client/src/filesaver/FileSaver.js"],"names":["XLSXExportUtils","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","36","ODataDataProvider","FileSaver","oData","fetch","requestData","getConverter","saveFile","37","getValue","oRow","oCol","keys","reduce","obj","key","convertData","aRows","aCols","forEach","col","row","getColsToConvert","mSettings","workbook","columns","result","properties","Array","unitProperty","push","aKeys","split","length","type","getDataConverter","aColumns","processDataUrl","sDataUrl","iSkip","iTop","mDataUrl","reSkip","reTop","URI","parse","query","test","serialize","build","fnProcessCallback","getUrl","sNextUrl","mNextUrl","dataUrl","replace","fnOnError","sMessage","error","fnOnDataReceived","oResult","aData","iFetchedRows","fPercent","iRemainingRows","mCallbackParams","bCancelled","value","results","isArray","iAvailableRows","iTotalRows","finished","progress","Math","round","__next","mRequest","min","iBatchSize","RequestHandler","sendRequest","then","catch","rows","fnConvertData","mDataSource","dataSource","count","MAX_ROWS","sizeLimit","batchSize","serviceUrl","url","mUri","path","slice","hash","fragment","method","useBatch","headers","cancel","38","oRequest","Error","sendBatchRequest","sendGetRequest","Promise","fnResolve","fnReject","sHeaderKey","xhr","XMLHttpRequest","onload","this","status","responseText","JSON","e","HTTP_WRONG_RESPONSE_MSG","onerror","HTTP_ERROR_MSG","onabort","open","setRequestHeader","toLowerCase","send","createGuid","r","random","toString","sKey","sValue","boundary","body","aLines","iEnd","iLength","iStart","oResponseData","join","39","blob","link","downloadSupported","fnSave","Blob","document","createElementNS","data","fileName","download","href","URL","createObjectURL","dispatchEvent","MouseEvent","reader","FileReader","onloadend","opened","window","location","readAsDataURL","navigator","msSaveOrOpenBlob"],"mappings":"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","file":"XLSXExportUtils.js","sourcesContent":["var XLSXExportUtils =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 36);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 36:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Bundle all utilities into a single module\r\nvar ODataDataProvider = __webpack_require__(37);\r\nvar FileSaver = __webpack_require__(39);\r\n\r\nmodule.exports = {\r\n\toData: {\r\n\t\tfetch: ODataDataProvider.requestData,\r\n\t\tgetConverter: ODataDataProvider.getConverter\r\n\t},\r\n\tsaveFile: FileSaver.saveFile\r\n};\n\n/***/ }),\n\n/***/ 37:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar RequestHandler = __webpack_require__(38);\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed.\r\n *\r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @returns {number|string|boolean} - The converted property value\r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\treturn oCol.keys.reduce(function(obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n *\r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * @returns {Array} - An array of rows\r\n *\r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function(col) {\r\n\t\taRows.forEach(function(row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n * E.g. handling data from association/navigationProperty\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @returns {Array} - Collection of columns that need special conversion for their values\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\r\n\t\tvar properties;\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\r\n\t\t// Handle unitPoperty which too could be from an association\r\n\t\tif (col.unitProperty) {\r\n\t\t\tproperties.push(col.unitProperty);\r\n\t\t}\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split('/');\r\n\r\n\t\t\tif (aKeys.length > 1) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\r\n *\r\n * @param {string} sDataUrl - URL that references the data on the OData service including filters and sorter\r\n * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n * @param {number} iTop - The amount of items that should be requested with this query\r\n * @returns {string} processed data URL\r\n */\r\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\r\n\tvar mDataUrl, reSkip = /\\$skip=[0-9]+/, reTop = /\\$top=[0-9]+/;\r\n\r\n\tif (!sDataUrl) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tmDataUrl = URI.parse(sDataUrl);\r\n\r\n\tmDataUrl.query = mDataUrl.query || '';\r\n\t// Add missing $skip if needed\r\n\tif (!reSkip.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\r\n\t}\r\n\t// Add missing $top if needed\r\n\tif (!reTop.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += '&$top=' + iTop;\r\n\t}\r\n\r\n\treturn (URI.serialize || URI.build)(mDataUrl);\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\r\n * @returns {Object} - Object reference that allows to cancel the current processing\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\t/**\r\n\t * Nested function to remove not used information from the URL\r\n\t *\r\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\r\n\t * @returns {string} - A clean URL\r\n\t */\r\n\tfunction cleanUrl(url) {\r\n\t\tvar mUri;\r\n\r\n\t\tif (!url) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tmUri = URI.parse(url);\r\n\r\n\t\tmUri.path = mUri.path || '';\r\n\t\tif (mUri.path.slice(-1) !== '/') {\r\n\t\t\tmUri.path = mUri.path + '/';\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates the download URL for the next query.\r\n\t *\r\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n\t * @param {number} iTop - The amount of items that should be requested with this query\r\n\t * @param {string} [sNextUrl] - A reference to the next bulk of data that was returned by the previous request\r\n\t * @returns {string} - The URL for the next query\r\n\t */\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl, mNextUrl;\r\n\r\n\t\tmDataUrl = URI.parse(dataUrl);\r\n\r\n\t\t/*\r\n\t\t * Use $skiptoken from response to query the next items.\r\n\t\t * OData V4 returns a relative path, while OData V2 returns\r\n\t\t * an absolute path. Therefore we need to use the original\r\n\t\t * URL to keep possible proxy settings and avoid any issues\r\n\t\t * between OData V4 and V2\r\n\t\t */\r\n\t\tif (sNextUrl) {\r\n\t\t\tmNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // Use $skip and $top\r\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\r\n\t\t\t\t.replace(/\\$skip=[0-9]+/g, '$skip=' + iSkip)\r\n\t\t\t\t.replace(/\\$top=[0-9]+/g, '$top=' + iTop);\r\n\t\t}\r\n\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // Cancelled by the application\r\n\t\t}\r\n\r\n\t\t/* Check for OData V4 result, if not present check for OData V2 result or apply default */\r\n\t\taData = (oResult && (oResult.value || (oResult.d && (oResult.d.results || oResult.d)))) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// Check if next url is provided\r\n\t\tsNextUrl = (oResult && (oResult['@odata.nextLink'] || (oResult.d && oResult.d.__next))) || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn { cancel: function() { bCancelled = true; } };\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n/***/ }),\n\n/***/ 38:\n/***/ (function(module, exports) {\n\n/**\r\n * Returns a promise that is resolved once the data is fetched\r\n */\r\n\r\nvar HTTP_ERROR_MSG = 'HTTP connection error';\r\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\r\n\r\n/**\r\n * This method creates an XMLHttpRequest from the provided\r\n * configuration and requests the data from the backend. The\r\n * configuration is configured to use OData services.\r\n *\r\n * @param {Object} oRequest - Request configuration object\r\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\r\n * @param {string} oRequest.url - References the resource URL that gets invoked\r\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\r\n */\r\nfunction sendRequest(oRequest) {\r\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\r\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\r\n\t}\r\n\r\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\r\n}\r\n\r\n/**\r\n * Creates and sends a GET request to the backend service.\r\n *\r\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\r\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\r\n */\r\nfunction sendGetRequest(oRequest) {\r\n\treturn new Promise(function(fnResolve, fnReject) {\r\n\t\tvar sHeaderKey;\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\r\n\t\txhr.onload = function() {\r\n\t\t\tif (this.status >= 400) {\r\n\t\t\t\tfnReject(this.responseText);\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.open('GET', oRequest.dataUrl, true);\r\n\t\txhr.setRequestHeader('accept', 'application/json');\r\n\r\n\t\t/* Set custom header information on the request as well as on the batch request */\r\n\t\tfor (sHeaderKey in oRequest.headers) {\r\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\r\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\txhr.send();\r\n\t});\r\n}\r\n\r\n/**\r\n * Creates a pseudo random GUID. This algorithm is not suitable for\r\n * cryptographic purposes and should not be used therefore.\r\n *\r\n * @returns {string} - Generated GUID\r\n */\r\nfunction createGuid() {\r\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\r\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\r\n\r\n\t\treturn v.toString(16);\r\n\t});\r\n}\r\n\r\n/**\r\n * Creates a $batch request and sends it to the backend service.\r\n *\r\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\r\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\r\n */\r\nfunction sendBatchRequest(oRequest) {\r\n\treturn new Promise(function(fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\tvar boundary = 'batch_' + createGuid();\r\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\r\n\t\tvar body = [];\r\n\t\tvar sKey, sValue;\r\n\r\n\t\txhr.onload = function() {\r\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\r\n\r\n\t\t\tresponseText = this.responseText;\r\n\t\t\taLines = this.responseText.split('\\r\\n');\r\n\r\n\t\t\t// TBD: check return codes\r\n\t\t\tiStart = 0;\r\n\t\t\tiLength = aLines.length;\r\n\t\t\tiEnd = iLength - 1;\r\n\r\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\r\n\t\t\t\tiStart++;\r\n\t\t\t}\r\n\r\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\r\n\t\t\t\tiEnd--;\r\n\t\t\t}\r\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\r\n\t\t\tresponseText = aLines.join('\\r\\n');\r\n\r\n\t\t\ttry {\r\n\t\t\t\toResponseData = JSON.parse(responseText);\r\n\t\t\t\tfnResolve(oResponseData);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\r\n\t\t// Create request\r\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\r\n\r\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\r\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\r\n\r\n\t\tbody.push('--' + boundary);\r\n\t\tbody.push('Content-Type: application/http');\r\n\t\tbody.push('Content-Transfer-Encoding: binary');\r\n\t\tbody.push('');\r\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\r\n\r\n\t\t/* Set header information on the request as well as on the batch request */\r\n\t\tfor (sKey in oRequest.headers) {\r\n\t\t\tsValue = oRequest.headers[sKey];\r\n\r\n\t\t\tif (sKey.toLowerCase() != 'accept') {\r\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\r\n\t\t\t}\r\n\t\t\tbody.push(sKey + ':' + sValue);\r\n\t\t}\r\n\r\n\t\tbody.push('');\r\n\t\tbody.push('');\r\n\t\tbody.push('--' + boundary + '--');\r\n\t\tbody.push('');\r\n\t\tbody = body.join('\\r\\n');\r\n\t\txhr.send(body);\r\n\t});\r\n}\r\n\r\nmodule.exports = { sendRequest: sendRequest };\n\n/***/ }),\n\n/***/ 39:\n/***/ (function(module, exports) {\n\n/**\r\n * The FileSaver allows to save browser generated files to\r\n * the local computer without using a proxy service.\r\n *\r\n * This class supports the latest version of the following browsers:\r\n *\r\n * Microsoft Internet Explorer 11\r\n * Microsoft Edge\r\n * Google Chrome\r\n * Mozilla Firefox\r\n * MacOS Safari\r\n * iOS Safari\r\n * Chrome for Android\r\n * SAP Fiori Client\r\n */\r\n\r\n/**\r\n * This function saves the provided Blob to the local file system.\r\n * The parameter name is optional and depending on the browser it\r\n * is not ensured that the filename can be applied. Google Chrome,\r\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\r\n * apply the filename correctly.\r\n *\r\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\r\n * @param {string} [name] - Filename of the file including the file extension\r\n */\r\nfunction saveFile(blob, name) {\r\n\tvar link, downloadSupported, fnSave;\r\n\r\n\t/* Ignore other formats than Blob */\r\n\tif (!(blob instanceof Blob)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\r\n\tdownloadSupported = 'download' in link;\r\n\r\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\r\n\tif (downloadSupported) {\r\n\t\tfnSave = function(data, fileName) {\r\n\t\t\tlink.download = fileName;\r\n\t\t\tlink.href = URL.createObjectURL(data);\r\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\r\n\t\t};\r\n\t}\r\n\r\n\t/* In case of iOS Safari, MacOS Safari */\r\n\tif (typeof fnSave === 'undefined') {\r\n\t\tfnSave = function(data) {\r\n\t\t\tvar reader = new FileReader();\r\n\r\n\t\t\treader.onloadend = function() {\r\n\t\t\t\tvar opened, url;\r\n\r\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n\t\t\t\topened = window.open(url, '_blank');\r\n\r\n\t\t\t\tif (!opened) {\r\n\t\t\t\t\twindow.location.href = url;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treader.readAsDataURL(blob);\r\n\t\t};\r\n\t}\r\n\r\n\t/*\r\n\t * IE/Edge implementation\r\n\t *\r\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\r\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\r\n\t */\r\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\r\n\t\tfnSave = function(data, fileName) {\r\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\r\n\t\t};\r\n\t}\r\n\r\n\t/* Save file to device */\r\n\tfnSave(blob, name);\r\n}\r\n\r\nmodule.exports = { saveFile: saveFile };\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// XLSXExportUtils.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 36);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 56e3809069578475695c","// Bundle all utilities into a single module\r\nvar ODataDataProvider = require('./provider/ODataDataProvider.js');\r\nvar FileSaver = require('./filesaver/FileSaver.js');\r\n\r\nmodule.exports = {\r\n\toData: {\r\n\t\tfetch: ODataDataProvider.requestData,\r\n\t\tgetConverter: ODataDataProvider.getConverter\r\n\t},\r\n\tsaveFile: FileSaver.saveFile\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/export-utils.js\n// module id = 36\n// module chunks = 1","var RequestHandler = require('./RequestHandler.js');\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed.\r\n *\r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @returns {number|string|boolean} - The converted property value\r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\treturn oCol.keys.reduce(function(obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n *\r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * @returns {Array} - An array of rows\r\n *\r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function(col) {\r\n\t\taRows.forEach(function(row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n * E.g. handling data from association/navigationProperty\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @returns {Array} - Collection of columns that need special conversion for their values\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\r\n\t\tvar properties;\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\r\n\t\t// Handle unitPoperty which too could be from an association\r\n\t\tif (col.unitProperty) {\r\n\t\t\tproperties.push(col.unitProperty);\r\n\t\t}\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split('/');\r\n\r\n\t\t\tif (aKeys.length > 1) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\r\n *\r\n * @param {string} sDataUrl - URL that references the data on the OData service including filters and sorter\r\n * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n * @param {number} iTop - The amount of items that should be requested with this query\r\n * @returns {string} processed data URL\r\n */\r\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\r\n\tvar mDataUrl, reSkip = /\\$skip=[0-9]+/, reTop = /\\$top=[0-9]+/;\r\n\r\n\tif (!sDataUrl) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tmDataUrl = URI.parse(sDataUrl);\r\n\r\n\tmDataUrl.query = mDataUrl.query || '';\r\n\t// Add missing $skip if needed\r\n\tif (!reSkip.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\r\n\t}\r\n\t// Add missing $top if needed\r\n\tif (!reTop.test(mDataUrl.query)) {\r\n\t\tmDataUrl.query += '&$top=' + iTop;\r\n\t}\r\n\r\n\treturn (URI.serialize || URI.build)(mDataUrl);\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\r\n * @returns {Object} - Object reference that allows to cancel the current processing\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\t/**\r\n\t * Nested function to remove not used information from the URL\r\n\t *\r\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\r\n\t * @returns {string} - A clean URL\r\n\t */\r\n\tfunction cleanUrl(url) {\r\n\t\tvar mUri;\r\n\r\n\t\tif (!url) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tmUri = URI.parse(url);\r\n\r\n\t\tmUri.path = mUri.path || '';\r\n\t\tif (mUri.path.slice(-1) !== '/') {\r\n\t\t\tmUri.path = mUri.path + '/';\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates the download URL for the next query.\r\n\t *\r\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\r\n\t * @param {number} iTop - The amount of items that should be requested with this query\r\n\t * @param {string} [sNextUrl] - A reference to the next bulk of data that was returned by the previous request\r\n\t * @returns {string} - The URL for the next query\r\n\t */\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl, mNextUrl;\r\n\r\n\t\tmDataUrl = URI.parse(dataUrl);\r\n\r\n\t\t/*\r\n\t\t * Use $skiptoken from response to query the next items.\r\n\t\t * OData V4 returns a relative path, while OData V2 returns\r\n\t\t * an absolute path. Therefore we need to use the original\r\n\t\t * URL to keep possible proxy settings and avoid any issues\r\n\t\t * between OData V4 and V2\r\n\t\t */\r\n\t\tif (sNextUrl) {\r\n\t\t\tmNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // Use $skip and $top\r\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\r\n\t\t\t\t.replace(/\\$skip=[0-9]+/g, '$skip=' + iSkip)\r\n\t\t\t\t.replace(/\\$top=[0-9]+/g, '$top=' + iTop);\r\n\t\t}\r\n\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // Cancelled by the application\r\n\t\t}\r\n\r\n\t\t/* Check for OData V4 result, if not present check for OData V2 result or apply default */\r\n\t\taData = (oResult && (oResult.value || (oResult.d && (oResult.d.results || oResult.d)))) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// Check if next url is provided\r\n\t\tsNextUrl = (oResult && (oResult['@odata.nextLink'] || (oResult.d && oResult.d.__next))) || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn { cancel: function() { bCancelled = true; } };\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/ODataDataProvider.js\n// module id = 37\n// module chunks = 1","/**\r\n * Returns a promise that is resolved once the data is fetched\r\n */\r\n\r\nvar HTTP_ERROR_MSG = 'HTTP connection error';\r\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\r\n\r\n/**\r\n * This method creates an XMLHttpRequest from the provided\r\n * configuration and requests the data from the backend. The\r\n * configuration is configured to use OData services.\r\n *\r\n * @param {Object} oRequest - Request configuration object\r\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\r\n * @param {string} oRequest.url - References the resource URL that gets invoked\r\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\r\n */\r\nfunction sendRequest(oRequest) {\r\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\r\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\r\n\t}\r\n\r\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\r\n}\r\n\r\n/**\r\n * Creates and sends a GET request to the backend service.\r\n *\r\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\r\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\r\n */\r\nfunction sendGetRequest(oRequest) {\r\n\treturn new Promise(function(fnResolve, fnReject) {\r\n\t\tvar sHeaderKey;\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\r\n\t\txhr.onload = function() {\r\n\t\t\tif (this.status >= 400) {\r\n\t\t\t\tfnReject(this.responseText);\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.open('GET', oRequest.dataUrl, true);\r\n\t\txhr.setRequestHeader('accept', 'application/json');\r\n\r\n\t\t/* Set custom header information on the request as well as on the batch request */\r\n\t\tfor (sHeaderKey in oRequest.headers) {\r\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\r\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\txhr.send();\r\n\t});\r\n}\r\n\r\n/**\r\n * Creates a pseudo random GUID. This algorithm is not suitable for\r\n * cryptographic purposes and should not be used therefore.\r\n *\r\n * @returns {string} - Generated GUID\r\n */\r\nfunction createGuid() {\r\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\r\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\r\n\r\n\t\treturn v.toString(16);\r\n\t});\r\n}\r\n\r\n/**\r\n * Creates a $batch request and sends it to the backend service.\r\n *\r\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\r\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\r\n */\r\nfunction sendBatchRequest(oRequest) {\r\n\treturn new Promise(function(fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\tvar boundary = 'batch_' + createGuid();\r\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\r\n\t\tvar body = [];\r\n\t\tvar sKey, sValue;\r\n\r\n\t\txhr.onload = function() {\r\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\r\n\r\n\t\t\tresponseText = this.responseText;\r\n\t\t\taLines = this.responseText.split('\\r\\n');\r\n\r\n\t\t\t// TBD: check return codes\r\n\t\t\tiStart = 0;\r\n\t\t\tiLength = aLines.length;\r\n\t\t\tiEnd = iLength - 1;\r\n\r\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\r\n\t\t\t\tiStart++;\r\n\t\t\t}\r\n\r\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\r\n\t\t\t\tiEnd--;\r\n\t\t\t}\r\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\r\n\t\t\tresponseText = aLines.join('\\r\\n');\r\n\r\n\t\t\ttry {\r\n\t\t\t\toResponseData = JSON.parse(responseText);\r\n\t\t\t\tfnResolve(oResponseData);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function() {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\r\n\t\t// Create request\r\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\r\n\r\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\r\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\r\n\r\n\t\tbody.push('--' + boundary);\r\n\t\tbody.push('Content-Type: application/http');\r\n\t\tbody.push('Content-Transfer-Encoding: binary');\r\n\t\tbody.push('');\r\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\r\n\r\n\t\t/* Set header information on the request as well as on the batch request */\r\n\t\tfor (sKey in oRequest.headers) {\r\n\t\t\tsValue = oRequest.headers[sKey];\r\n\r\n\t\t\tif (sKey.toLowerCase() != 'accept') {\r\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\r\n\t\t\t}\r\n\t\t\tbody.push(sKey + ':' + sValue);\r\n\t\t}\r\n\r\n\t\tbody.push('');\r\n\t\tbody.push('');\r\n\t\tbody.push('--' + boundary + '--');\r\n\t\tbody.push('');\r\n\t\tbody = body.join('\\r\\n');\r\n\t\txhr.send(body);\r\n\t});\r\n}\r\n\r\nmodule.exports = { sendRequest: sendRequest };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/RequestHandler.js\n// module id = 38\n// module chunks = 1","/**\r\n * The FileSaver allows to save browser generated files to\r\n * the local computer without using a proxy service.\r\n *\r\n * This class supports the latest version of the following browsers:\r\n *\r\n * Microsoft Internet Explorer 11\r\n * Microsoft Edge\r\n * Google Chrome\r\n * Mozilla Firefox\r\n * MacOS Safari\r\n * iOS Safari\r\n * Chrome for Android\r\n * SAP Fiori Client\r\n */\r\n\r\n/**\r\n * This function saves the provided Blob to the local file system.\r\n * The parameter name is optional and depending on the browser it\r\n * is not ensured that the filename can be applied. Google Chrome,\r\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\r\n * apply the filename correctly.\r\n *\r\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\r\n * @param {string} [name] - Filename of the file including the file extension\r\n */\r\nfunction saveFile(blob, name) {\r\n\tvar link, downloadSupported, fnSave;\r\n\r\n\t/* Ignore other formats than Blob */\r\n\tif (!(blob instanceof Blob)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\r\n\tdownloadSupported = 'download' in link;\r\n\r\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\r\n\tif (downloadSupported) {\r\n\t\tfnSave = function(data, fileName) {\r\n\t\t\tlink.download = fileName;\r\n\t\t\tlink.href = URL.createObjectURL(data);\r\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\r\n\t\t};\r\n\t}\r\n\r\n\t/* In case of iOS Safari, MacOS Safari */\r\n\tif (typeof fnSave === 'undefined') {\r\n\t\tfnSave = function(data) {\r\n\t\t\tvar reader = new FileReader();\r\n\r\n\t\t\treader.onloadend = function() {\r\n\t\t\t\tvar opened, url;\r\n\r\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n\t\t\t\topened = window.open(url, '_blank');\r\n\r\n\t\t\t\tif (!opened) {\r\n\t\t\t\t\twindow.location.href = url;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treader.readAsDataURL(blob);\r\n\t\t};\r\n\t}\r\n\r\n\t/*\r\n\t * IE/Edge implementation\r\n\t *\r\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\r\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\r\n\t */\r\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\r\n\t\tfnSave = function(data, fileName) {\r\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\r\n\t\t};\r\n\t}\r\n\r\n\t/* Save file to device */\r\n\tfnSave(blob, name);\r\n}\r\n\r\nmodule.exports = { saveFile: saveFile };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/filesaver/FileSaver.js\n// module id = 39\n// module chunks = 1"],"sourceRoot":""}